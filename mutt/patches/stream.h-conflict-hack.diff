Unfortunately mutt has various macros and enums named using a "M_FOO"
convention, which conflicts with sys/stream.h on illumos. Up until 1.6.0 things
happened to work, because "mutt.h" was always included before <sys/socket.h>
(which happens to pull in sys/stream.h) in compilation units, but getdomain.c
in 1.6.0 does the opposite, which causes a build failure (the preprocessor
expands M_READ which is used as a value in an enum declaration in mutt.h).

This patch works around the problem by renaming the M_READ enum value in mutt
to MUTT_READ and the M_CMD macro to MUTT_CMD. It's a stupid hack and likely
painful to maintain, but it doesn't seem to be possible to avoid inclusion of
stream.h.

diff --git a/commands.c b/commands.c
index 2a0cdc9..ffc13ee 100644
--- a/commands.c
+++ b/commands.c
@@ -225,7 +225,7 @@ int mutt_display_message (HEADER *cur)
     if (!option (OPTNOCURSES))
       keypad (stdscr, TRUE);
     if (r != -1)
-      mutt_set_flag (Context, cur, M_READ, 1);
+      mutt_set_flag (Context, cur, MUTT_READ, 1);
     if (r != -1 && option (OPTPROMPTAFTER))
     {
       mutt_unget_event (mutt_any_key_to_continue _("Command: "), 0);
@@ -490,7 +490,7 @@ void mutt_pipe_message (HEADER *h)
   char buffer[LONG_STRING];
 
   buffer[0] = 0;
-  if (mutt_get_field (_("Pipe to command: "), buffer, sizeof (buffer), M_CMD)
+  if (mutt_get_field (_("Pipe to command: "), buffer, sizeof (buffer), MUTT_CMD)
       != 0 || !buffer[0])
     return;
 
@@ -592,7 +592,7 @@ void mutt_shell_escape (void)
   char buf[LONG_STRING];
 
   buf[0] = 0;
-  if (mutt_get_field (_("Shell command: "), buf, sizeof (buf), M_CMD) == 0)
+  if (mutt_get_field (_("Shell command: "), buf, sizeof (buf), MUTT_CMD) == 0)
   {
     if (!buf[0] && Shell)
       strfcpy (buf, Shell, sizeof (buf));
diff --git a/curs_main.c b/curs_main.c
index a76aac9..3192a9f 100644
--- a/curs_main.c
+++ b/curs_main.c
@@ -1682,7 +1682,7 @@ int mutt_index_menu (void)
 		  Context->hdrs[Context->v2r[j]]->old)
 		mutt_set_flag (Context, Context->hdrs[Context->v2r[j]], M_NEW, 1);
 	      else
-		mutt_set_flag (Context, Context->hdrs[Context->v2r[j]], M_READ, 1);
+		mutt_set_flag (Context, Context->hdrs[Context->v2r[j]], MUTT_READ, 1);
 	    }
 	  }
 	  menu->redraw = REDRAW_STATUS | REDRAW_INDEX;
@@ -1692,7 +1692,7 @@ int mutt_index_menu (void)
 	  if (CURHDR->read || CURHDR->old)
 	    mutt_set_flag (Context, CURHDR, M_NEW, 1);
 	  else
-	    mutt_set_flag (Context, CURHDR, M_READ, 1);
+	    mutt_set_flag (Context, CURHDR, MUTT_READ, 1);
 
 	  if (option (OPTRESOLVE))
 	  {
@@ -2143,7 +2143,7 @@ int mutt_index_menu (void)
         /* L10N: CHECK_ACL */
 	CHECK_ACL(M_ACL_SEEN, _("Cannot mark message(s) as read"));
 
-	rc = mutt_thread_set_flag (CURHDR, M_READ, 1,
+	rc = mutt_thread_set_flag (CURHDR, MUTT_READ, 1,
 				   op == OP_MAIN_READ_THREAD ? 0 : 1);
 
 	if (rc != -1)
diff --git a/editmsg.c b/editmsg.c
index 8ba3105..611ca65 100644
--- a/editmsg.c
+++ b/editmsg.c
@@ -200,7 +200,7 @@ static int edit_one_message (CONTEXT *ctx, HEADER *cur)
   if (rc == 0)
   {
     mutt_set_flag (Context, cur, M_DELETE, 1);
-    mutt_set_flag (Context, cur, M_READ, 1);
+    mutt_set_flag (Context, cur, MUTT_READ, 1);
 
     if (option (OPTDELETEUNTAG))
       mutt_set_flag (Context, cur, M_TAG, 0);
diff --git a/enter.c b/enter.c
index 23610ae..12b82e4 100644
--- a/enter.c
+++ b/enter.c
@@ -256,7 +256,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int y, int x,
     hclass = HC_FILE;
   else if (flags & M_EFILE)
     hclass = HC_MBOX;
-  else if (flags & M_CMD)
+  else if (flags & MUTT_CMD)
     hclass = HC_CMD;
   else if (flags & M_ALIAS)
     hclass = HC_ALIAS;
@@ -522,7 +522,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int y, int x,
 	case OP_EDITOR_COMPLETE:
 	case OP_EDITOR_COMPLETE_QUERY:
 	  state->tabs++;
-	  if (flags & M_CMD)
+	  if (flags & MUTT_CMD)
 	  {
 	    for (i = state->curpos; i && !is_shell_char(state->wbuf[i-1]); i--)
 	      ;
diff --git a/flags.c b/flags.c
index f0f3d81..8235920 100644
--- a/flags.c
+++ b/flags.c
@@ -148,7 +148,7 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
       }
       break;
 
-    case M_READ:
+    case MUTT_READ:
 
       if (!mutt_bit_isset(ctx->rights,M_ACL_SEEN))
 	return;
@@ -350,9 +350,9 @@ int mutt_change_flag (HEADER *h, int bf)
     case 'o':
     case 'O':
       if (h)
-	mutt_set_flag (Context, h, M_READ, !bf);
+	mutt_set_flag (Context, h, MUTT_READ, !bf);
       else
-	mutt_tag_set_flag (M_READ, !bf);
+	mutt_tag_set_flag (MUTT_READ, !bf);
       flag = M_OLD;
       break;
 
diff --git a/imap/imap.c b/imap/imap.c
index 1b63b3a..f066b11 100644
--- a/imap/imap.c
+++ b/imap/imap.c
@@ -896,7 +896,7 @@ static int imap_make_msg_set (IMAP_DATA* idata, BUFFER* buf, int flag,
           if (hdrs[n]->old != HEADER_DATA(hdrs[n])->old)
             match = invert ^ hdrs[n]->old;
 	  break;
-        case M_READ:
+        case MUTT_READ:
           if (hdrs[n]->read != HEADER_DATA(hdrs[n])->read)
             match = invert ^ hdrs[n]->read;
 	  break;
@@ -952,7 +952,7 @@ static int imap_make_msg_set (IMAP_DATA* idata, BUFFER* buf, int flag,
  *     pre, message set, post
  *   flag: enum of flag type on which to filter
  *   changed: include only changed messages in message set
- *   invert: invert sense of flag, eg M_READ matches unread messages
+ *   invert: invert sense of flag, eg MUTT_READ matches unread messages
  * Returns: number of matched messages, or -1 on failure */
 int imap_exec_msgset (IMAP_DATA* idata, const char* pre, const char* post,
                       int flag, int changed, int invert)
@@ -1259,7 +1259,7 @@ int imap_sync_mailbox (CONTEXT* ctx, int expunge, int* index_hint)
   if (rc >= 0)
     rc |= sync_helper (idata, M_ACL_WRITE, M_OLD, "Old");
   if (rc >= 0)
-    rc |= sync_helper (idata, M_ACL_SEEN, M_READ, "\\Seen");
+    rc |= sync_helper (idata, M_ACL_SEEN, MUTT_READ, "\\Seen");
   if (rc >= 0)
     rc |= sync_helper (idata, M_ACL_WRITE, M_REPLIED, "\\Answered");
 
diff --git a/imap/message.c b/imap/message.c
index 02a726f..99a7723 100644
--- a/imap/message.c
+++ b/imap/message.c
@@ -1061,7 +1061,7 @@ char* imap_set_flags (IMAP_DATA* idata, HEADER* h, char* s)
 
   mutt_set_flag (ctx, h, M_NEW, !(hd->read || hd->old));
   mutt_set_flag (ctx, h, M_OLD, hd->old);
-  mutt_set_flag (ctx, h, M_READ, hd->read);
+  mutt_set_flag (ctx, h, MUTT_READ, hd->read);
   mutt_set_flag (ctx, h, M_DELETE, hd->deleted);
   mutt_set_flag (ctx, h, M_FLAG, hd->flagged);
   mutt_set_flag (ctx, h, M_REPLIED, hd->replied);
diff --git a/mbox.c b/mbox.c
index 95cba65..4a39171 100644
--- a/mbox.c
+++ b/mbox.c
@@ -1224,7 +1224,7 @@ int mutt_reopen_mailbox (CONTEXT *ctx, int *index_hint)
 	  mutt_set_flag (ctx, ctx->hdrs[i], M_FLAG, old_hdrs[j]->flagged);
 	  mutt_set_flag (ctx, ctx->hdrs[i], M_REPLIED, old_hdrs[j]->replied);
 	  mutt_set_flag (ctx, ctx->hdrs[i], M_OLD, old_hdrs[j]->old);
-	  mutt_set_flag (ctx, ctx->hdrs[i], M_READ, old_hdrs[j]->read);
+	  mutt_set_flag (ctx, ctx->hdrs[i], MUTT_READ, old_hdrs[j]->read);
 	}
 	mutt_set_flag (ctx, ctx->hdrs[i], M_DELETE, old_hdrs[j]->deleted);
 	mutt_set_flag (ctx, ctx->hdrs[i], M_TAG, old_hdrs[j]->tagged);
diff --git a/mh.c b/mh.c
index bc87660..82c72f7 100644
--- a/mh.c
+++ b/mh.c
@@ -1868,7 +1868,7 @@ static void maildir_update_flags (CONTEXT *ctx, HEADER *o, HEADER *n)
   if (o->replied != n->replied)
     mutt_set_flag (ctx, o, M_REPLIED, n->replied);
   if (o->read != n->read)
-    mutt_set_flag (ctx, o, M_READ, n->read);
+    mutt_set_flag (ctx, o, MUTT_READ, n->read);
   if (o->old != n->old)
     mutt_set_flag (ctx, o, M_OLD, n->old);
 
diff --git a/mutt.h b/mutt.h
index de26fd8..d2135b6 100644
--- a/mutt.h
+++ b/mutt.h
@@ -83,7 +83,7 @@
 #define  M_ALIAS   1      /* do alias "completion" by calling up the alias-menu */
 #define  M_FILE    (1<<1) /* do file completion */
 #define  M_EFILE   (1<<2) /* do file completion, plus incoming folders */
-#define  M_CMD     (1<<3) /* do completion on previous word */
+#define  MUTT_CMD     (1<<3) /* do completion on previous word */
 #define  M_PASS    (1<<4) /* password mode (no echo) */
 #define  M_CLEAR   (1<<5) /* clear input if printable character is pressed */
 #define  M_COMMAND (1<<6) /* do command completion */
@@ -177,7 +177,7 @@ enum
   M_NEW,
   M_OLD,
   M_REPLIED,
-  M_READ,
+  MUTT_READ,
   M_UNREAD,
   M_DELETE,
   M_UNDELETE,
diff --git a/pager.c b/pager.c
index 8bfe72c..7a9819f 100644
--- a/pager.c
+++ b/pager.c
@@ -1605,7 +1605,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
   if (IsHeader (extra) && !extra->hdr->read)
   {
     Context->msgnotreadyet = extra->hdr->msgno;
-    mutt_set_flag (Context, extra->hdr, M_READ, 1);
+    mutt_set_flag (Context, extra->hdr, MUTT_READ, 1);
   }
 
   lineInfo = safe_malloc (sizeof (struct line_t) * (maxLine = LINES));
@@ -2670,7 +2670,7 @@ search_next:
 	if (extra->hdr->read || extra->hdr->old)
 	  mutt_set_flag (Context, extra->hdr, M_NEW, 1);
 	else if (!first)
-	  mutt_set_flag (Context, extra->hdr, M_READ, 1);
+	  mutt_set_flag (Context, extra->hdr, MUTT_READ, 1);
 	first = 0;
         Context->msgnotreadyet = -1;
 	redraw = REDRAW_STATUS | REDRAW_INDEX;
diff --git a/pattern.c b/pattern.c
index d954cdc..d0ab445 100644
--- a/pattern.c
+++ b/pattern.c
@@ -83,7 +83,7 @@ Flags[] =
   { 'P', M_PERSONAL_FROM,	0,		NULL },
   { 'Q', M_REPLIED,		0,		NULL },
   { 'r', M_DATE_RECEIVED,	0,		eat_date },
-  { 'R', M_READ,		0,		NULL },
+  { 'R', MUTT_READ,		0,		NULL },
   { 's', M_SUBJECT,		0,		eat_regexp },
   { 'S', M_SUPERSEDED,		0,		NULL },
   { 't', M_TO,			0,		eat_regexp },
@@ -1125,7 +1125,7 @@ mutt_pattern_exec (struct pattern_t *pat, pattern_exec_flag flags, CONTEXT *ctx,
       return (pat->not ^ h->replied);
     case M_OLD:
       return (pat->not ? (!h->old || h->read) : (h->old && !h->read));
-    case M_READ:
+    case MUTT_READ:
       return (pat->not ^ h->read);
     case M_DELETED:
       return (pat->not ^ h->deleted);
diff --git a/recvattach.c b/recvattach.c
index 5424eda..acf0ccb 100644
--- a/recvattach.c
+++ b/recvattach.c
@@ -673,7 +673,7 @@ void mutt_pipe_attachment_list (FILE *fp, int tag, BODY *top, int filter)
   memset (&state, 0, sizeof (STATE));
 
   if (mutt_get_field ((filter ? _("Filter through: ") : _("Pipe to: ")),
-				  buf, sizeof (buf), M_CMD) != 0 || !buf[0])
+				  buf, sizeof (buf), MUTT_CMD) != 0 || !buf[0])
     return;
 
   mutt_expand_path (buf, sizeof (buf));
diff --git a/score.c b/score.c
index 6f952a5..c1f6b90 100644
--- a/score.c
+++ b/score.c
@@ -149,7 +149,7 @@ void mutt_score_message (CONTEXT *ctx, HEADER *hdr, int upd_ctx)
   if (hdr->score <= ScoreThresholdDelete)
     _mutt_set_flag (ctx, hdr, M_DELETE, 1, upd_ctx);
   if (hdr->score <= ScoreThresholdRead)
-    _mutt_set_flag (ctx, hdr, M_READ, 1, upd_ctx);
+    _mutt_set_flag (ctx, hdr, MUTT_READ, 1, upd_ctx);
   if (hdr->score >= ScoreThresholdFlag)
     _mutt_set_flag (ctx, hdr, M_FLAG, 1, upd_ctx);
 }
